---
title: 'Sentry Error Tracking'
description: 'Real-time error tracking and performance monitoring for Bindu agents'
---

# Sentry Error Tracking

Sentry is a real-time error tracking and performance monitoring platform that helps you identify, diagnose, and fix issues in production. Bindu includes built-in Sentry integration to provide comprehensive observability for your AI agents.

---

## Why Use Sentry?

### 1. Real-Time Error Tracking

Sentry captures and reports errors as they happen:
- **Automatic error capture** - Exceptions are caught and reported automatically
- **Stack traces** - Full context of where and why errors occurred
- **Breadcrumbs** - Trail of events leading up to the error
- **User context** - Know which users are affected
- **Environment context** - Server, release, and deployment information

Never miss critical errors in production.

### 2. Performance Monitoring

Track application performance and identify bottlenecks:
- **Transaction tracing** - Monitor request/response times
- **Database query performance** - Identify slow queries
- **External API calls** - Track third-party service latency
- **Custom instrumentation** - Measure specific operations
- **Performance trends** - Historical performance data

Optimize your agent's response time and throughput.

### 3. Release Health Tracking

Monitor the health of your deployments:
- **Crash-free sessions** - Track stability across releases
- **Adoption rate** - See how quickly users upgrade
- **Issue regression** - Detect when bugs reappear
- **Deploy markers** - Correlate issues with deployments

Know immediately if a deployment introduces problems.

### 4. Intelligent Alerting

Get notified when things go wrong:
- **Smart grouping** - Similar errors grouped together
- **Alert rules** - Custom thresholds and conditions
- **Integration** - Slack, PagerDuty, email, webhooks
- **Noise reduction** - Filter out expected errors

Focus on what matters, reduce alert fatigue.

### 5. Deep Integration

Bindu's Sentry integration captures:
- **Starlette/FastAPI** - HTTP request errors and performance
- **SQLAlchemy** - Database query errors and slow queries
- **Redis** - Cache and queue operation errors
- **Loguru** - Application logs as breadcrumbs
- **Asyncio** - Async task errors and context

Complete visibility across your entire stack.

### 6. Privacy & Compliance

Sentry respects user privacy:
- **PII scrubbing** - Automatically filter sensitive data
- **Custom filters** - Define what data to exclude
- **On-premise option** - Self-hosted Sentry for complete control
- **GDPR compliant** - Meets European privacy standards

Track errors without compromising user privacy.

---

## When to Use Sentry

✅ **Use Sentry when:**
- Running in production environments
- Need to track errors across multiple instances
- Want performance monitoring and optimization
- Require alerting for critical errors
- Building enterprise applications
- Need audit trails and compliance
- Want to improve agent reliability

❌ **Consider alternatives when:**
- Only developing locally (use console logs)
- Cost is a major constraint (Sentry has free tier but limits)
- You already have a comprehensive monitoring solution

---

## Architecture

Bindu's Sentry integration works seamlessly with your application:

```
┌─────────────────────────────────────────┐
│         Bindu Agent Instances           │
│  ┌─────┐  ┌─────┐  ┌─────┐  ┌─────┐   │
│  │ Pod1│  │ Pod2│  │ Pod3│  │ Pod4│   │
│  └──┬──┘  └──┬──┘  └──┬──┘  └──┬──┘   │
└─────┼────────┼────────┼────────┼────────┘
      │        │        │        │
      │   Sentry SDK (automatic capture)
      │        │        │        │
      └────────┴────────┴────────┘
                  │
         ┌────────▼────────┐
         │   Sentry.io     │
         │   (Cloud/Self-  │
         │    Hosted)      │
         │                 │
         │  ┌───────────┐  │
         │  │  Errors   │  │
         │  ├───────────┤  │
         │  │Performance│  │
         │  ├───────────┤  │
         │  │ Releases  │  │
         │  └───────────┘  │
         └─────────────────┘
                  │
         ┌────────▼────────┐
         │   Alerts &      │
         │   Notifications │
         │                 │
         │  Slack, Email,  │
         │  PagerDuty, etc │
         └─────────────────┘
```

### How It Works

1. **Automatic Instrumentation**: Sentry SDK hooks into Starlette, SQLAlchemy, Redis, etc.
2. **Error Capture**: Exceptions are caught and enriched with context
3. **Transmission**: Events sent to Sentry (batched for efficiency)
4. **Processing**: Sentry groups, analyzes, and stores events
5. **Alerting**: Notifications sent based on alert rules
6. **Analysis**: View errors, performance, and trends in Sentry UI

---

## Configuration

Sentry can be configured in **two ways**: via environment variables or directly in your agent code.

### Option 1: In-Code Configuration (Recommended)

Configure Sentry directly in your `bindufy()` config:

```python
from bindu.penguin.bindufy import bindufy

config = {
    "author": "your.email@example.com",
    "name": "production_agent",
    "description": "Production agent with Sentry tracking",
    "deployment": {
        "url": "http://localhost:3773",
        "expose": True
    },
    "skills": ["skills/question-answering"],
    
    # Sentry configuration
    "sentry": {
        "enabled": True,
        "dsn": "https://examplePublicKey@o0.ingest.sentry.io/0",
        "environment": "production",
        "release": "my-agent@1.0.0",  # Optional
        "traces_sample_rate": 1.0,  # 100% of errors
        "profiles_sample_rate": 0.1,  # 10% of transactions
        "enable_tracing": True,
        "send_default_pii": False,  # Disable in production
        "debug": False,
    }
}

def handler(messages):
    # Your agent logic
    pass

bindufy(config, handler)
```

**Benefits:**
- ✅ No environment variables needed
- ✅ Configuration lives with your code
- ✅ Easy to version control
- ✅ Perfect for packages and libraries
- ✅ Different configs for different agents

### Option 2: Environment Variables

Configure via `.env` file or environment:

```bash
# Enable Sentry
SENTRY__ENABLED=true

# Sentry DSN (get from your Sentry project settings)
SENTRY__DSN=https://examplePublicKey@o0.ingest.sentry.io/0

# Environment (production, staging, development)
SENTRY__ENVIRONMENT=production

# Release version (optional, defaults to bindu version)
SENTRY__RELEASE=bindu@1.0.0

# Error sampling (1.0 = 100% of errors)
SENTRY__TRACES_SAMPLE_RATE=1.0

# Performance sampling (0.1 = 10% of transactions)
SENTRY__PROFILES_SAMPLE_RATE=0.1

# Enable performance monitoring
SENTRY__ENABLE_TRACING=true

# Disable PII in production
SENTRY__SEND_DEFAULT_PII=false
```

Then use minimal config:

```python
config = {
    "author": "your.email@example.com",
    "name": "production_agent",
    "description": "Production agent",
    "deployment": {"url": "http://localhost:3773", "expose": True},
    "skills": []
    # Sentry configured via environment variables
}

bindufy(config, handler)
```

**Benefits:**
- ✅ Separate config from code
- ✅ Easy to change without code changes
- ✅ Good for deployment pipelines

### Configuration Priority

If both are provided, **in-code config takes precedence**:

1. **In-code config** (`config["sentry"]`) - Highest priority
2. **Environment variables** (`SENTRY__*`) - Fallback

This allows you to override environment variables when needed.

### Configuration Options

```python
"sentry": {
    "enabled": True,                    # Enable/disable Sentry
    "dsn": "https://...",               # Your Sentry DSN
    "environment": "production",        # Environment name
    "release": "my-agent@1.0.0",       # Optional: Release version
    "traces_sample_rate": 1.0,         # 1.0 = 100% of errors
    "profiles_sample_rate": 0.1,       # 0.1 = 10% of transactions
    "enable_tracing": True,            # Performance monitoring
    "send_default_pii": False,         # Disable PII in production
    "debug": False,                    # Debug mode
}
```

---

## What Gets Tracked

### ✅ All HTTP Endpoints (Automatic)

The `StarletteIntegration` automatically instruments **all** Starlette routes:

#### 1. A2A Protocol Endpoint
- `POST /` - Main agent communication endpoint
- Captures errors and performance

#### 2. Agent Card Endpoint
- `GET /.well-known/agent.json` - Agent discovery
- Tracks endpoint availability

#### 3. DID Endpoints
- `GET/POST /did/resolve` - DID resolution
- Monitors identity operations

#### 4. Skills Endpoints
- `GET /agent/skills` - List all skills
- `GET /agent/skills/{skill_id}` - Get skill details
- `GET /agent/skills/{skill_id}/documentation` - Get skill docs

#### 5. Payment Session Endpoints (X402)
- `POST /api/start-payment-session` - Start payment
- `GET /payment-capture` - Payment capture page
- `GET /api/payment-status/{session_id}` - Payment status

#### 6. Static/UI Endpoints
- `GET /docs` - Chat UI
- `GET /favicon.ico` - Favicon
- `GET /static/*` - Static files (CSS/JS)

### ✅ Database Operations (SQLAlchemy)

When using PostgreSQL storage:

**Captured automatically:**
- SQL queries (parameterized, no sensitive data)
- Query execution time
- Database connection errors
- Slow query warnings
- Transaction failures

### ✅ Redis Operations

When using Redis scheduler:

**Captured automatically:**
- Redis commands (LPUSH, BRPOP, etc.)
- Command execution time
- Connection errors
- Timeout errors
- Queue operations

### ✅ Logging Events

All error-level logs are sent to Sentry:

```python
from bindu.utils.logging import get_logger

logger = get_logger("my_module")

# This creates a Sentry event
logger.error("Task processing failed", task_id=task_id, error=str(e))

# These become breadcrumbs (context for errors)
logger.info("Processing task", task_id=task_id)
logger.debug("Fetching from database")
```

**Captured:**
- Error-level logs → Sentry events
- All logs → Breadcrumbs (context trail)

### ✅ Async Operations

Async task errors are captured:

**Captured automatically:**
- Unhandled exceptions in async tasks
- Coroutine context
- Task stack traces

### ❌ What's NOT Captured (Filtered)

**Health Check Endpoints:**
- `/healthz`
- `/health`
- `/metrics`
- `/favicon.ico`

**Sensitive Data (PII Scrubbing):**

Automatically filtered:
- `authorization` headers
- `x-api-key` headers
- `cookie` headers
- `password` fields
- `token` fields
- `secret` fields
- `api_key` fields
- `private_key` fields

---

## Getting Started

### 1. Create Sentry Account

Sign up for a free Sentry account:
- Go to [sentry.io](https://sentry.io)
- Create an account (free tier available)
- Create a new project (select "Python" as platform)

### 2. Get Your DSN

From your Sentry project settings:
1. Navigate to **Settings** → **Projects** → **[Your Project]**
2. Go to **Client Keys (DSN)**
3. Copy the DSN URL

It looks like:
```
https://examplePublicKey@o0.ingest.sentry.io/0
```

### 3. Configure Bindu

Add to your agent config:

```python
config = {
    "author": "your.email@example.com",
    "name": "my_agent",
    "description": "My awesome agent",
    "deployment": {"url": "http://localhost:3773", "expose": True},
    "skills": [],
    
    "sentry": {
        "enabled": True,
        "dsn": "https://your-key@o0.ingest.sentry.io/123456",
        "environment": "production",
        "traces_sample_rate": 1.0,
        "profiles_sample_rate": 0.1,
    }
}
```

### 4. Run Your Agent

```bash
python my_agent.py
```

Sentry will automatically initialize on startup. You'll see:
```
✅ Sentry initialized successfully
```

### 5. Test Error Tracking

Trigger a test error:

```python
from bindu.observability import capture_exception

try:
    1 / 0
except Exception as e:
    capture_exception(e, tags={"test": "true"})
```

Check your Sentry dashboard - the error should appear within seconds!

---

## Features

### Automatic Error Capture

All unhandled exceptions are automatically captured:

```python
def handler(messages):
    # This error will be automatically sent to Sentry
    result = some_function_that_might_fail()
    return result
```

### Manual Error Capture

Capture specific errors with additional context:

```python
from bindu.observability import capture_exception

try:
    risky_operation()
except Exception as e:
    capture_exception(
        e,
        tags={"operation": "risky", "user_id": "123"},
        extra={"input_data": data}
    )
```

### Breadcrumbs

Add breadcrumbs for debugging context:

```python
from bindu.observability import add_breadcrumb

add_breadcrumb(
    message="User requested task",
    category="task",
    level="info",
    data={"task_id": "123", "type": "question-answering"}
)
```

Breadcrumbs appear in error reports, showing what happened before the error.

### User Context

Associate errors with specific users:

```python
from bindu.observability import set_user

set_user(
    user_id="user-123",
    email="user@example.com",
    username="john_doe"
)
```

### Custom Context

Add custom context to errors:

```python
from bindu.observability import set_context

set_context("task", {
    "task_id": "task-123",
    "conversation_id": "conv-456",
    "status": "working"
})
```

### Performance Monitoring

Track custom operations:

```python
from bindu.observability import start_transaction

with start_transaction(name="process_task", op="task") as transaction:
    # Your code here
    result = process_task(task_id)
    
    # Add custom measurements
    transaction.set_measurement("tokens_used", 1500, "token")
```

### Message Capture

Send informational messages to Sentry:

```python
from bindu.observability import capture_message

capture_message(
    "High memory usage detected",
    level="warning",
    tags={"component": "worker"},
    extra={"memory_mb": 8192}
)
```

---

## Best Practices

### 1. Environment Configuration

Use different environments for different deployments:

```bash
# Production
SENTRY__ENVIRONMENT=production
SENTRY__TRACES_SAMPLE_RATE=1.0
SENTRY__PROFILES_SAMPLE_RATE=0.1

# Staging
SENTRY__ENVIRONMENT=staging
SENTRY__TRACES_SAMPLE_RATE=1.0
SENTRY__PROFILES_SAMPLE_RATE=0.5

# Development
SENTRY__ENABLED=false  # Or use a separate Sentry project
```

### 2. Release Tracking

Set release version for deployment tracking:

```bash
SENTRY__RELEASE=bindu@1.2.3
```

Or use git commit SHA:
```bash
SENTRY__RELEASE=bindu@$(git rev-parse --short HEAD)
```

### 3. Sample Rates

Adjust sampling based on traffic:

**Low traffic** (< 1000 requests/day):
```bash
SENTRY__TRACES_SAMPLE_RATE=1.0  # 100% of errors
SENTRY__PROFILES_SAMPLE_RATE=1.0  # 100% of transactions
```

**Medium traffic** (1000-10000 requests/day):
```bash
SENTRY__TRACES_SAMPLE_RATE=1.0  # 100% of errors
SENTRY__PROFILES_SAMPLE_RATE=0.1  # 10% of transactions
```

**High traffic** (> 10000 requests/day):
```bash
SENTRY__TRACES_SAMPLE_RATE=1.0  # 100% of errors (always capture errors)
SENTRY__PROFILES_SAMPLE_RATE=0.01  # 1% of transactions
```

### 4. PII Scrubbing

Never send sensitive data to Sentry:

```bash
# Production - disable PII
SENTRY__SEND_DEFAULT_PII=false
```

Sentry automatically scrubs:
- Passwords
- API keys
- Tokens
- Credit card numbers
- Social security numbers

### 5. Filter Noise

Ignore expected errors:

```python
# In settings.py
SENTRY__IGNORE_ERRORS=["KeyboardInterrupt", "SystemExit", "ExpectedError"]
```

Filter health check transactions:

```python
# In settings.py
SENTRY__FILTER_TRANSACTIONS=["/healthz", "/health", "/metrics"]
```

### 6. Alert Configuration

Set up alerts in Sentry UI:
- **Critical errors**: Immediate notification (Slack, PagerDuty)
- **Performance degradation**: Daily digest
- **New issues**: Weekly summary

### 7. Context Enrichment

Always add context to manual captures:

```python
# Good
capture_exception(
    error,
    tags={"component": "task_processor", "task_type": "qa"},
    extra={"task_id": task_id, "input_size": len(messages)}
)

# Bad
capture_exception(error)  # No context
```

---

## Monitoring & Dashboards

### Sentry Dashboard

Key metrics to monitor:

1. **Error Rate**: Errors per hour/day
2. **Crash-Free Sessions**: % of sessions without crashes
3. **Response Time**: p50, p95, p99 latencies
4. **Throughput**: Requests per second
5. **Top Errors**: Most frequent errors
6. **Slow Transactions**: Slowest operations

### Custom Dashboards

Create custom dashboards for:
- Task processing performance
- LLM API latency
- Database query performance
- Redis operation metrics
- User-specific errors

### Alerts

Set up alerts for:
- Error rate > threshold
- New error types
- Performance degradation
- Specific error patterns
- Release health issues

---

## Troubleshooting

### Sentry Not Initializing

**Symptom**: No errors appearing in Sentry

**Solutions**:
1. Check `SENTRY__ENABLED=true`
2. Verify DSN is correct
3. Check network connectivity to Sentry
4. Look for initialization errors in logs

---

### Too Many Events

**Symptom**: Hitting Sentry quota limits

**Solutions**:
1. Reduce `SENTRY__PROFILES_SAMPLE_RATE`
2. Filter out noisy transactions
3. Ignore expected errors
4. Upgrade Sentry plan

---

### Missing Context

**Symptom**: Errors lack debugging information

**Solutions**:
1. Add breadcrumbs before operations
2. Set user context
3. Add custom context
4. Increase `SENTRY__MAX_BREADCRUMBS`

---

### Performance Impact

**Symptom**: Sentry slowing down application

**Solutions**:
1. Reduce sampling rates
2. Disable profiling
3. Filter transactions
4. Use async transport (default)

---

## Security Considerations

### 1. DSN Protection

The DSN is public but rate-limited:
- Don't commit DSN to public repos (use environment variables)
- Rotate DSN if exposed
- Use Sentry's rate limiting

### 2. PII Scrubbing

Always disable PII in production:
```bash
SENTRY__SEND_DEFAULT_PII=false
```

### 3. Data Retention

Configure data retention in Sentry:
- Default: 90 days
- Can be reduced for compliance
- Can be extended with paid plans

### 4. Self-Hosted Option

For maximum control, use self-hosted Sentry:
```bash
# Point to your self-hosted instance
SENTRY__DSN=https://key@sentry.yourcompany.com/project-id
```

---

## Cost Optimization

### Free Tier

Sentry's free tier includes:
- 5,000 errors/month
- 10,000 performance units/month
- 1 project
- 30-day data retention

### Optimization Tips

1. **Sample transactions**: Use low `PROFILES_SAMPLE_RATE`
2. **Filter noise**: Exclude health checks, metrics
3. **Ignore errors**: Filter expected errors
4. **Use environments**: Separate dev/staging/prod projects
5. **Monitor quota**: Set up quota alerts

### Paid Plans

Consider paid plans for:
- Higher error volume
- More projects
- Longer retention
- Advanced features (SAML SSO, etc.)

---

## Comparison with Alternatives

| Feature | Sentry | Rollbar | Bugsnag | Datadog |
|---------|--------|---------|---------|---------|
| Error tracking | ✅ Excellent | ✅ Good | ✅ Good | ✅ Good |
| Performance | ✅ Built-in | ❌ Limited | ❌ Limited | ✅ Excellent |
| Free tier | ✅ 5K errors | ✅ 5K errors | ✅ 7K errors | ⚠️ Trial only |
| Self-hosted | ✅ Yes | ❌ No | ❌ No | ❌ No |
| Python support | ✅ Excellent | ✅ Good | ✅ Good | ✅ Excellent |
| Integrations | ✅ Extensive | ⚠️ Moderate | ⚠️ Moderate | ✅ Extensive |
| Best for | General use | Error tracking | Mobile apps | Full observability |

---

## Conclusion

Sentry provides comprehensive error tracking and performance monitoring for Bindu agents. It offers:

- ✅ **Real-time error tracking**: Catch issues as they happen
- ✅ **Performance monitoring**: Optimize agent response times
- ✅ **Release health**: Track deployment stability
- ✅ **Deep integration**: Starlette, SQLAlchemy, Redis, Loguru
- ✅ **Privacy-first**: PII scrubbing and compliance
- ✅ **Free tier**: Get started without cost

For production Bindu deployments, Sentry is essential for maintaining reliability and quickly resolving issues.

---

**Next Steps:**
- [PostgreSQL Storage Documentation](../storage/overview)
- [Redis Scheduler Documentation](../scheduler/overview)
- [Sentry Documentation](https://docs.sentry.io)
