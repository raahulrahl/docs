---
title: 'Built for the Internet of Agents'
---

Transform any agent into a production-ready server that speaks universal protocols.

```mermaid
%%{init: {'theme':'base', 'themeVariables': { 'fontSize':'10px'}, 'flowchart':{'nodeSpacing': 30, 'rankSpacing': 40}}}%%
graph TB
    Client[Client/Orchestrator] --> Discovery[Skills Discovery<br/>Match Task to Agent]
    
    Discovery --> Request[HTTP Request<br/>A2A/X402]
    
    Request --> Payment{Payment<br/>Required?}
    Payment -->|Yes| PayFlow[X402 Payment Flow<br/>Sign & Verify]
    Payment -->|No| Auth[Auth & DID<br/>Verification]
    PayFlow --> Auth
    
    Auth --> Server[BinduApplication<br/>Web Server]
    
    Server --> Manager[TaskManager<br/>Coordinates Everything]
    
    Manager --> Queue[Scheduler<br/>Task Queue]
    Manager <--> Storage[(Storage<br/>PostgreSQL/Redis)]
    
    Queue --> Worker[Worker<br/>Executes Tasks]
    
    Worker --> Agent[Your AI Agent<br/>LangChain/CrewAI/etc]
    
    Agent --> Response[Response<br/>with Results]
    
    Manager -.Traces.-> Observability[Observability<br/>Phoenix/Langfuse/Jaeger]
    Worker -.Traces.-> Observability
    Agent -.Traces.-> Observability
    
    style Client fill:#e1f5ff
    style Discovery fill:#d4f5e1
    style Request fill:#e1f5ff
    style Payment fill:#98fb98
    style PayFlow fill:#98fb98
    style Auth fill:#ffd4e1
    style Server fill:#fff4e1
    style Manager fill:#ffe1f5
    style Queue fill:#e1ffe1
    style Worker fill:#ffe1e1
    style Agent fill:#e1f5ff
    style Response fill:#e1f5ff
    style Storage fill:#e1ffe1
    style Observability fill:#ffd700
```

**How It Works**

1. **Discovery**: Client finds agents via `/agent/skills` endpoint
2. **Submit Task**: Send message via `message/send` ‚Üí Task enters **"submitted"** state
3. **Payment** (optional): X402 verifies payment if required
4. **Authentication**: Auth0 + DID verify identity
5. **Processing**: Task moves to **"working"** state, agent executes
6. **Interactive Loop**: If agent needs input, task enters **"input-required"** state
7. **Completion**: Task reaches **"completed"** state with artifacts
8. **Observability**: Full trace captured via Phoenix/Langfuse/Jaeger

### Task Lifecycle & States

Bindu uses a **task-first pattern** where every interaction is a trackable, resumable task with persistent state:

```mermaid
%%{init: {'theme':'base', 'themeVariables': { 'fontSize':'11px'}, 'flowchart':{'nodeSpacing': 40, 'rankSpacing': 50}}}%%
stateDiagram-v2
    [*] --> submitted: message/send
    submitted --> working: Agent starts processing
    submitted --> input_required: Agent needs clarification
    working --> input_required: Agent asks question
    input_required --> submitted: User responds (same taskId)
    working --> completed: Task finishes
    working --> failed: Error occurs
    submitted --> canceled: tasks/cancel
    working --> canceled: tasks/cancel
    completed --> [*]
    failed --> [*]
    canceled --> [*]
    
    note right of input_required
        Interactive conversations
        Agent asks, user answers
        Context preserved
    end note
    
    note right of completed
        Returns artifacts
        Full conversation history
        DID-signed results
    end note
```

**Core States:**

| State | Description | Can Cancel? | Next Actions |
|-------|-------------|-------------|--------------|
| **`submitted`** | Task received, queued for processing | ‚úÖ Yes | Wait or poll with `tasks/get` |
| **`working`** | Agent actively processing | ‚úÖ Yes | Wait for completion or input request |
| **`input-required`** | Agent needs user input to continue | ‚úÖ Yes | Send follow-up message with same `taskId` |
| **`completed`** | Task finished successfully | ‚ùå No | Retrieve artifacts, submit feedback |
| **`failed`** | Task encountered an error | ‚ùå No | Check error details, retry if needed |
| **`canceled`** | Task was canceled by user | ‚ùå No | Create new task if needed |

**Key Features:**

- **Resumable Conversations**: Tasks can pause for user input and resume seamlessly
- **Context Preservation**: Full conversation history maintained across all states
- **Reference Previous Tasks**: Use `referenceTaskIds` to build on prior results
- **Async by Default**: Submit task, get immediate response, poll for completion
- **Artifact Storage**: Final results stored with DID signatures for verification

**Example Flow:**

```python
# 1. Submit task
response = await agent.send_message("create sunset caption")
# State: "submitted" ‚Üí "input-required"
# Agent asks: "Which platform? Instagram, Pinterest, or General?"

# 2. Check status
task = await agent.get_task(task_id)
# State: "input-required"
# History shows agent's question

# 3. Respond to agent (same taskId, new messageId)
response = await agent.send_message("Instagram", task_id=task_id)
# State: "submitted" ‚Üí "working" ‚Üí "completed"

# 4. Get final result
task = await agent.get_task(task_id)
# State: "completed"
# Artifacts: ["Chasing sunsets and dreams. üåÖ #SunsetLovers"]

# 5. Build on previous result (new task, reference old one)
response = await agent.send_message(
    "make it shorter",
    reference_task_ids=[task_id]
)
# Agent accesses previous caption and shortens it
# Result: "Sunset vibes. üåÖ #GoldenHour"
```

<Tip>
**Why This Matters**: Unlike stateless APIs, Bindu preserves the entire conversation context. Agents can ask clarifying questions, users can provide additional input, and subsequent tasks can reference previous results‚Äîenabling true multi-turn agent interactions.
</Tip>

### Protocol-Native Architecture

- **Universal Protocol Support**: Native [A2A](https://github.com/a2aproject/A2A), [AP2](https://github.com/google-agentic-commerce/AP2), and [X402](https://github.com/coinbase/x402) compliance out of the box.

- **Framework Agnostic**: Works with [Agno](https://github.com/agno-agi/agno), [LangChain](https://github.com/langchain-ai/langchain), [CrewAI](https://github.com/crewAIInc/crewAI), [LlamaIndex](https://developers.llamaindex.ai/python/framework/use_cases/agents/), [FastAgent](https://github.com/evalstate/fast-agent), and any Python-based framework.

- **DID Authentication**: Built-in Decentralized Identity for secure agent-to-agent communication. Influenced by [AT Protocol DID structure](https://atproto.com/specs/did).

- **Type Safe**: Enforce structured I/O through schema validation for predictable behavior.

### Infrastructure & Deployment

- **Simple Server Setup**: Turn your AI agent into [a web server using Starlette (a Python web framework)](https://github.com/getbindu/Bindu/blob/main/bindu/server/applications.py). The `BinduApplication` class handles all the complex setup. You just provide your agent and it creates a fully functional server ready to receive requests.

- **Built-In Reliability**: Comes with automatic error handling, task retry mechanisms, health checks, and backup systems. If something fails, [Bindu knows how to recover gracefully without crashing your agent](https://github.com/getbindu/Bindu/blob/main/bindu/server/task_manager.py).

- **Run Anywhere**: Start on your local machine (localhost) and deploy to any cloud platform when ready. [Works with Docker and Podman containers](https://github.com/getbindu/create-bindu-agent/blob/main/%7B%7Bcookiecutter.project_name%7D%7D/docker-compose.yml), making it easy to package and ship your agent to production environments.

### Observability & Monitoring

- **Built-in Tracing**: Native integration with Phoenix, Langfuse, and Jaeger for complete visibility.

- **Real-time Monitoring**: Track agent health, performance metrics, and execution flows.

- **Error Tracking**: Comprehensive error handling and logging for distributed systems.

### Storage & Orchestration

- **Flexible Storage**: Choose between in-memory, PostgreSQL, or Redis for context and history.

- **Distributed Scheduling**: Redis-based scheduler for coordinating tasks across agent instances.

- **Intelligent Routing**: Analyze tasks and route to agents based on capabilities and availability.

- **Execution Modes**: Sequential, parallel, or collaborative patterns for complex workflows.

### Payment & Commerce

- **X402 Payment Rails**: Native support for agent-to-agent payments and micropayments.

- **AP2 Commerce Protocol**: Enable agents to participate in agentic commerce ecosystems.

### Security & Privacy

- **Multi-Provider Auth**: Support for AuthKit, GitHub, AWS Cognito, Google, and Azure.

- **Private by Default**: Runs in your infrastructure‚Äîno external data sharing or vendor lock-in.

### Developer Experience

- **2-Minute Setup**: Production-ready agent with `create-bindu-agent` cookiecutter template.

- **Best Practices Built-in**: Pre-configured with ruff, ty, pytest, and pre-commit hooks.

- **113+ Built-in Toolkits**: Access thousands of tools across data, code, web, and enterprise APIs.

- **MCP Integration**: First-class Model Context Protocol support to connect agents with external systems.

<Card title="Start Building" icon="code" href="/bindu/introduction/create-agent">
  Create your first Bindu agent ‚Üí
</Card>
