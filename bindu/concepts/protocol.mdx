---
title: "Protocol Types"
---

# The Language of Agents

Think of protocol types as the vocabulary that agents use to talk to each other. Just like humans need a common language to communicate, agents need a precise set of data structures to understand each other. This guide explains each type in simple terms.

## Overview

Bindu follows two main protocols:
- **A2A (Agent-to-Agent) Protocol v0.3.0** - The standard for agent communication
- **AP2 (Agent Protocol 2) v0.1.0** - Extensions for advanced features

<Note>
Some types are marked as `<NotPartOfA2A>` - these are Bindu-specific extensions that go beyond the standard A2A protocol.
</Note>

---

## Core Building Blocks

### Type Aliases & Enums

Protocol types use TypeAlias definitions for enums to ensure type safety and clear state management.

#### TaskState

Defines all possible states a task can be in during its lifecycle:

**Standard A2A States:**
- `submitted` - Task has been submitted and is awaiting execution
- `working` - Agent is actively working on the task
- `input-required` - Task is paused, waiting for user input
- `completed` - Task has been successfully completed
- `canceled` - Task has been canceled by the user
- `failed` - Task failed due to an error during execution
- `rejected` - Task was rejected by the agent and was not started
- `auth-required` - Task requires authentication to proceed

**Bindu Extensions** `<NotPartOfA2A>`:
- `payment-required` - Task requires payment to proceed
- `unknown` - Task is in an unknown or indeterminate state
- `trust-verification-required` - Task requires trust verification to proceed
- `pending` - Task is pending execution
- `suspended` - Task is suspended and not currently running
- `resumed` - Task is resumed and currently running
- `negotiation-bid-submitted` - Task is submitted for negotiation
- `negotiation-bid-lost` - Task bid was lost in negotiation
- `negotiation-bid-won` - Task bid was won in negotiation

#### NegotiationStatus `<NotPartOfA2A>`

Defines the status of individual negotiation proposals:

- `proposed` - Negotiation is proposed
- `accepted` - Negotiation is accepted
- `rejected` - Negotiation is rejected
- `countered` - Counter-offer made

#### NegotiationSessionStatus `<NotPartOfA2A>`

Defines the overall status of a negotiation session:

- `initiated` - Negotiation session is initiated
- `ongoing` - Negotiation session is ongoing
- `completed` - Negotiation session is completed
- `rejected` - Negotiation session is rejected

#### TrustLevel `<NotPartOfA2A>`

Defines role-based trust levels for agent authorization (ordered by permission level):

- `super_admin` - Highest level access, all operations permitted
- `admin` - Admin operations, minimal risk
- `manager` - Management operations, elevated permissions
- `operator` - System operations, moderate risk
- `editor` - Edit operations, moderate risk
- `analyst` - Standard operations
- `auditor` - Sensitive operations (read-only)
- `support` - Support operations, troubleshooting access
- `viewer` - View-only access, minimal permissions
- `guest` - Limited access, read-only operations

#### IdentityProvider `<NotPartOfA2A>`

Supported authentication identity providers:

- `keycloak` - Keycloak identity provider
- `azure_ad` - Azure AD identity provider
- `okta` - Okta identity provider
- `auth0` - Auth0 identity provider
- `custom` - Custom identity provider

#### Data Key Constants

Standard keys for structured data in DataPart objects:

- `CONTACT_ADDRESS_DATA_KEY` = `"contact_picker.ContactAddress"`
- `PAYMENT_METHOD_DATA_DATA_KEY` = `"payment_request.PaymentMethodData"`
- `CART_MANDATE_DATA_KEY` = `"ap2.mandates.CartMandate"`
- `INTENT_MANDATE_DATA_KEY` = `"ap2.mandates.IntentMandate"`
- `PAYMENT_MANDATE_DATA_KEY` = `"ap2.mandates.PaymentMandate"`

These constants are used to identify specific data types within the protocol's DataPart structure.

### Parts: The Content Pieces

Parts are the fundamental building blocks for agent communication in A2A. Here's how they work in practice:

#### TextPart: Simple Text Communication

**Schema:**
```python
class TextPart(TypedDict):
    """Represents a text segment within a message or artifact."""
    
    kind: Literal["text"]           # Discriminator, always "text"
    text: str                       # The actual text content
    metadata: NotRequired[dict[str, Any]]  # Optional metadata for context
    embeddings: NotRequired[list[float]] #The embeddings of Text. <NotPartOfA2A>
```

**Use Case 1: User Instruction**
```json
{
  "kind": "text",
  "text": "Analyze this image and highlight any faces."
}
```

**Use Case 2: Agent Status with Metadata**
```json
{
  "kind": "text",
  "text": "Processing your request... Found 3 faces in the image.",
  "metadata": {
    "timestamp": "2025-10-31T10:00:00Z",
    "confidence": 0.95,
    "processingTime": "2.3s"
  }
}
```

**What it's for:** Human-readable communication including instructions, status updates, error messages, and conversational text between agents and users.

---

#### FilePart: Binary Content Exchange

**Schema:**
```python
class FileWithBytes(TypedDict):
    """File representation with binary content."""
    
    bytes: str                      # Base64-encoded file content
    name: NotRequired[str]          # File name (e.g., "document.pdf")
    mimeType: NotRequired[str]      # MIME type (e.g., "application/pdf")
    embeddings: NotRequired[list[float]] #The embeddings of File. <NotPartOfA2A>


class FileWithUri(TypedDict):
    """File representation with URI reference."""
    
    uri: str                        # URL pointing to file content
    name: NotRequired[str]          # File name
    mimeType: NotRequired[str]      # MIME type


class FilePart(TypedDict):
    """Represents a file segment within a message or artifact."""
    
    kind: Literal["file"]           # Discriminator, always "file"
    file: FileWithBytes | FileWithUri  # File content (bytes or URI)
    metadata: NotRequired[dict[str, Any]]  # Optional metadata
    embeddings: NotRequired[list[float]] #The embeddings of File. <NotPartOfA2A>
```

**Use Case 1: Image Upload with Bytes (Client → Agent)**
```json
{
  "jsonrpc": "2.0",
  "id": "req-007",
  "method": "message/send",
  "params": {
    "message": {
      "role": "user",
      "parts": [
        {
          "kind": "text",
          "text": "Analyze this image and highlight any faces."
        },
        {
          "kind": "file",
          "file": {
            "name": "input_image.png",
            "mimeType": "image/png",
            "bytes": "iVBORw0KGgoAAAANSUhEUgAAAAUA..."
          }
        }
      ],
      "messageId": "6dbc13b5-bd57-4c2b-b503-24e381b6c8d6"
    }
  }
}
```

**What it's for:** Binary content exchange including images, documents, media files, and data files. Use `bytes` for small files (< 1MB), `uri` for large files to avoid payload bloat.

---

#### DataPart: Structured Information Exchange

**Schema:**
```python
class DataPart(TypedDict):
    """Represents a structured data segment (e.g., JSON) within a message or artifact."""
    
    kind: Literal["data"]           # Discriminator, always "data"
    data: dict[str, Any]            # Structured JSON data
    metadata: NotRequired[dict[str, Any]]  # Optional metadata
    embeddings: NotRequired[list[float]] #The embeddings of Data. <NotPartOfA2A>
```

**Use Case 1: Form Data Submission**
```json
{
  "kind": "data",
  "data": {
    "formType": "user_registration",
    "fields": {
      "username": "john_doe",
      "email": "john@example.com",
      "preferences": {
        "newsletter": true,
        "notifications": "daily"
      }
    },
    "timestamp": "2025-10-31T10:00:00Z"
  }
}
```

**What it's for:** Structured, machine-readable information including API responses, form data, query results, analytics, payment details, and any JSON-serializable data that needs programmatic processing.

---

#### Key Takeaways: A2A Part Usage

**Part Types (A2A Standard):**

1. **TextPart** (`kind: "text"`): For conveying plain textual content
   - Use for: Instructions, descriptions, status updates, conversational text
   
2. **FilePart** (`kind: "file"`): For conveying file-based content
   - **FileWithBytes**: Small files provided as base64-encoded bytes
   - **FileWithUri**: Large files referenced by URI
   - Optional: `name` and `mimeType` fields
   
3. **DataPart** (`kind: "data"`): For conveying structured JSON data
   - Use for: Forms, parameters, machine-readable information
   - Data is a JSON object (`dict[str, Any]`)

**Common Features:**
- All parts support optional `metadata` field for additional context
- Parts can be used in both Messages and Artifacts
- Multiple parts can be combined in a single message

**Bindu Extensions** `<NotPartOfA2A>`:
- `embeddings: list[float]` - Vector embeddings for semantic search and similarity

**Best Practices:**
- Use `bytes` for small files, `uri` for large files to avoid payload bloat
- Always specify `mimeType` for files to help agents process content correctly
- Use `metadata` for additional context (timestamps, confidence scores, error codes)
- Structure DataPart content with clear, consistent schemas

---

## Communication Types

### Message: Operational Communication

Messages are the primary way agents, users, and systems communicate during task execution. Unlike artifacts (which contain final results), messages carry operational content like instructions, status updates, and coordination.

**Schema:**
```python
class Message(TypedDict):
    """Communication content exchanged between agents, users, and systems.
    
    Messages represent all non-result communication in the bindu protocol.
    Unlike Artifacts (which contain task outputs), Messages carry operational
    content like instructions, status updates, context, and metadata.
    
    Message Types:
    - User Instructions: Task requests with context and files
    - Agent Communication: Status updates, thoughts, coordination
    - System Messages: Errors, warnings, protocol information
    - Context Sharing: Background information, references, metadata
    
    Multi-part Structure:
    Messages can contain multiple parts to organize different content types:
    - Text parts for instructions or descriptions
    - File parts for context documents or references
    - Data parts for structured metadata or parameters
    
    Flow Pattern:
    Client → Message (request) → Agent → Message (status) → Artifact (result)
    """
    
    message_id: Required[UUID]
    """Identifier created by the message creator."""
    
    context_id: Required[UUID]
    """The context the message is associated with."""
    
    task_id: Required[UUID]
    """Identifier of task the message is related to."""
    
    kind: Required[Literal["message"]]
    """The type discriminator, always "message"."""
    
    role: Required[Literal["user", "agent", "system"]]
    """The role of the message sender."""
    
    parts: Required[list[Part]]
    """The content parts of the message."""
    
    metadata: NotRequired[dict[str, Any]]
    """Metadata associated with the message."""
    
    reference_task_ids: NotRequired[list[UUID]]
    """List of identifiers of tasks that this message references."""
    
    extensions: NotRequired[list[str]]
    """Array of extension URIs."""
```

**Message Roles:**

1. **user**: Messages from humans or client applications
   - Task instructions and requests
   - Follow-up questions
   - Input responses
   
2. **agent**: Messages from AI agents
   - Status updates ("Processing your request...")
   - Thought processes and reasoning
   - Coordination between agents
   - Progress notifications
   
3. **system**: Protocol-level messages `<NotPartOfA2A>`
   - Error notifications
   - Authentication warnings
   - Protocol-level events

**Use Case 1: User Instruction with Context**
```json
{
  "messageId": "6dbc13b5-bd57-4c2b-b503-24e381b6c8d6",
  "contextId": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "taskId": "f9e8d7c6-b5a4-3210-9876-543210fedcba",
  "kind": "message",
  "role": "user",
  "parts": [
    {
      "kind": "text",
      "text": "Analyze this sales data and identify trends."
    },
    {
      "kind": "file",
      "file": {
        "name": "sales_q4.csv",
        "mimeType": "text/csv",
        "uri": "https://example.com/files/sales_q4.csv"
      }
    }
  ],
  "metadata": {
    "priority": "high",
    "deadline": "2025-11-01T00:00:00Z"
  }
}
```


**What it's for:** Real-time communication during task execution including instructions, status updates, questions, coordination, and context sharing. Messages enable interactive, multi-turn conversations between users and agents.

---

### Artifact: Task Results

Artifacts are the **final, immutable outputs** produced by agents after completing work. Once created, they cannot be modified. Ensuring a permanent, trustworthy record of agent execution. They represent tangible deliverables like reports, generated code, processed files, or analysis results. Unlike messages (which are ephemeral communication), artifacts are the persistent, unchangeable products of agent work that can be reliably referenced, shared, and audited.

**Schema:**
```python
class Artifact(TypedDict):
    """Represents the final output generated by an agent after completing a task.
    
    Artifacts are immutable data structures that contain the results of agent execution.
    They can contain multiple parts (text, files, structured data) and are uniquely
    identified for tracking and retrieval.
    
    A single task may produce multiple artifacts when the output naturally
    separates into distinct deliverables (e.g., frontend + backend code).
    """
    
    artifact_id: Required[UUID]
    """Unique identifier for the artifact."""
    
    name: NotRequired[str]
    """Human-readable name of the artifact."""
    
    description: NotRequired[str]
    """A description of the artifact."""
    
    parts: NotRequired[list[Part]]
    """The content parts that make up the artifact."""
    
    metadata: NotRequired[dict[str, Any]]
    """Metadata about the artifact."""
    
    extensions: NotRequired[list[str]]
    """Array of extension URIs."""
    
    append: NotRequired[bool]
    """Whether to append this artifact to an existing one. <NotPartOfA2A>"""
    
    last_chunk: NotRequired[bool]
    """Whether this is the last chunk of the artifact. <NotPartOfA2A>"""
```

**Key Differences from Messages:**
- **Messages** = Operational communication during work (ephemeral)
- **Artifacts** = Final deliverable results after work (persistent)

**Use Case 1: Analysis Report Artifact**
```json
{
  "artifactId": "artifact-001",
  "name": "Q4 Sales Analysis Report",
  "description": "Comprehensive analysis of Q4 sales trends and patterns",
  "parts": [
    {
      "kind": "text",
      "text": "# Q4 Sales Analysis\n\n## Key Findings\n1. Revenue increased 23% compared to Q3\n2. Top performing region: West Coast (35% of total)\n3. Mobile sales grew 45% year-over-year\n\n## Recommendations\n- Increase inventory for top-selling products\n- Expand mobile marketing campaigns\n- Focus on West Coast market expansion"
    },
    {
      "kind": "data",
      "data": {
        "summary": {
          "totalRevenue": 2450000,
          "growthRate": 0.23,
          "topRegion": "West Coast",
          "mobileGrowth": 0.45
        },
        "trends": [
          {"month": "October", "revenue": 750000},
          {"month": "November", "revenue": 820000},
          {"month": "December", "revenue": 880000}
        ]
      }
    }
  ],
  "metadata": {
    "generatedAt": "2025-10-31T10:30:00Z",
    "analysisType": "quarterly_sales",
    "dataSource": "sales_q4.csv"
  }
}
```

**What it's for:** Persistent, immutable deliverables that represent the completed work of an agent. Artifacts are the tangible outputs that users receive after task completion - reports, generated code, processed files, analysis results, or any final product of agent execution.

---

### Communication Flow Pattern

Understanding the relationship between Messages, Tasks, and Artifacts:

**Basic Task Execution Flow:**
```
1. Client sends Message (user instruction)
   → Server creates Task (state: "submitted")
   ↓
2. Task transitions to "working"
   → Agent processes the request
   ↓
3. Task produces Artifact (final result)
   ↓
4. Task transitions to "completed"
   → Client receives Task with Artifact
```

**Streaming Task Execution Flow:**
```
1. Client sends Message via message/stream
   → Server creates Task (state: "submitted")
   ↓
2. Task transitions to "working"
   → Server sends status-update events
   ↓
3. Agent produces Artifact chunks
   → Server sends artifact-update events (append: true/false)
   ↓
4. Task transitions to "completed"
   → Server sends final status-update (final: true)
```

**Multi-Turn Interaction Flow:**
```
1. Client sends Message (initial request)
   → Server creates Task (state: "submitted")
   ↓
2. Task transitions to "input-required"
   → Server includes agent Message asking for clarification
   ↓
3. Client sends Message (with taskId, providing input)
   → Task resumes processing
   ↓
4. Task produces Artifact and transitions to "completed"
```

**Key Concepts:**

**Messages:**
- Carry instructions, context, and communication
- User messages initiate or continue tasks
- Agent messages provide status or request input
- Messages are part of the task's `history` array

**Tasks:**
- Central coordination unit tracking work lifecycle
- Created by server in response to user messages
- Contain status, history, and artifacts
- State transitions: `submitted` → `working` → `completed`

**Artifacts:**
- Final, immutable outputs attached to completed tasks
- Delivered as part of the task result
- Can be streamed in chunks for large outputs
- Multiple artifacts possible per task

**Example: Simple Question**
```json
// Client sends message
{
  "method": "message/send",
  "params": {
    "message": {
      "role": "user",
      "parts": [{"kind": "text", "text": "Analyze sales trends"}],
      "messageId": "msg-001"
    }
  }
}

// Server responds with completed task
{
  "result": {
    "id": "task-001",
    "contextId": "ctx-001",
    "status": {"state": "completed"},
    "artifacts": [{
      "artifactId": "art-001",
      "name": "Sales Analysis",
      "parts": [{"kind": "text", "text": "Revenue increased 23%..."}]
    }],
    "history": [/* user message */],
    "kind": "task"
  }
}
```

---

## Task Management

### Task
A **Task** is the central coordination unit. It tracks the complete lifecycle of work from request to completion.

```typescript
{
  "id": "uuid",
  "context_id": "uuid",
  "kind": "task",
  "status": {
    "state": "working",
    "timestamp": "2025-10-10T10:00:00Z",
    "message": {}
  },
  "artifacts": [],
  "history": [],
  "metadata": {}
}
```

**Task States:**

**Standard States:**
- **submitted**: Task created, waiting to start
- **working**: Agent actively processing
- **input-required**: Paused, needs user input
- **completed**: Successfully finished
- **canceled**: User stopped the task
- **failed**: Error occurred
- **rejected**: Agent declined the task
- **auth-required**: Needs authentication

**Bindu Extensions:**
- **payment-required**: Needs payment to proceed
- **unknown**: State unclear
- **trust-verification-required**: Needs trust verification
- **pending**: Queued for execution
- **suspended**: Temporarily paused
- **resumed**: Restarted after suspension
- **negotiation-bid-submitted**: In negotiation
- **negotiation-bid-won**: Won the bid
- **negotiation-bid-lost**: Lost the bid

**Task Lifecycle:**
1. **Creation**: Client sends initial message with requirements
2. **Processing**: Agent works and updates status
3. **Communication**: Back-and-forth messages as needed
4. **Artifact Generation**: Agent produces results
5. **Completion**: Final status and artifact delivery

### Context
A **Context** groups related tasks into a conversation session. Think of it as a workspace where multiple tasks can share history and state.

```typescript
{
  "context_id": "uuid",
  "kind": "context",
  "name": "Customer Support Session",
  "description": "Helping user with billing issue",
  "role": "support",
  "tasks": [],
  "status": "active",
  "created_at": "2023-10-27T10:00:00Z",
  "updated_at": "2023-10-27T10:00:00Z",
  "tags": ["billing", "urgent"],
  "metadata": {}
}
```

**Why Contexts Matter:**
- **Continuity**: Maintain conversation across multiple tasks
- **History**: Preserve what happened before
- **Organization**: Group related work together
- **References**: Tasks can reference earlier context

**Example:** A user debugging an issue might create multiple tasks (check logs, analyze error, propose fix) all within the same context, so each task has access to previous findings.

---

## Security & Authentication

### Security Schemes
Bindu supports multiple authentication methods:

#### HTTP Authentication
```json
{
  "type": "http",
  "scheme": "bearer",
  "bearer_format": "JWT"
}
```

#### API Key
```json
{
  "type": "apiKey",
  "name": "X-API-Key",
  "in_": "header"
}
```

#### OAuth2
```json
{
  "type": "oauth2",
  "flows": {
    "authorizationCode": {
      "authorizationUrl": "https://auth.example.com/oauth/authorize",
      "tokenUrl": "https://auth.example.com/oauth/token"
    }
  }
}
```

#### OpenID Connect
```json
{
  "type": "openIdConnect",
  "open_id_connect_url": "https://auth.example.com/.well-known/openid-configuration"
}
```

#### Mutual TLS
```json
{
  "type": "mutualTLS",
  "description": "Client certificate authentication"
}
```

### Trust Levels
Bindu uses role-based trust levels to control what agents can do:

- **super_admin**: Full system access
- **admin**: Administrative operations
- **manager**: Management operations with elevated permissions
- **operator**: System operations, moderate risk
- **editor**: Edit operations, moderate risk
- **analyst**: Standard operations
- **auditor**: Sensitive operations (read-only)
- **support**: Troubleshooting access
- **viewer**: View-only, minimal permissions
- **guest**: Limited read-only access

### Identity Providers
Supported authentication providers:
- **keycloak**: Open-source identity management
- **azure_ad**: Microsoft Azure Active Directory
- **okta**: Okta identity platform
- **auth0**: Auth0 authentication service
- **custom**: Custom identity provider

---

## Notifications

### Push Notifications
For real-time updates when tasks change state:

```typescript
{
  "id": "uuid",
  "url": "https://client.example.com/webhook",
  "token": "secret-token",
  "authentication": {
    "type": "http",
    "scheme": "bearer"
  }
}
```

**Use Cases:**
- Notify client when task completes
- Alert on errors or state changes
- Stream progress updates

### Task Events

#### Status Update Event
```typescript
{
  "task_id": "uuid",
  "context_id": "uuid",
  "kind": "status-update",
  "status": {
    "state": "completed",
    "timestamp": "2025-10-10T10:00:00Z"
  },
  "final": true
}
```

#### Artifact Update Event
```typescript
{
  "task_id": "uuid",
  "context_id": "uuid",
  "kind": "artifact-update",
  "artifact": {/* artifact object */},
  "append": false,
  "last_chunk": true
}
```

---

## Payment & Commerce (AP2 Protocol)

### Payment Types

#### Contact Address
Physical address for shipping:

```typescript
{
  "recipient": "John Doe",
  "address_line": ["123 Main St", "Apt 4B"],
  "city": "San Francisco",
  "region": "CA",
  "postal_code": "94102",
  "country": "US",
  "phone_number": "+1-555-0123"
}
```

#### Payment Currency Amount
```typescript
{
  "currency": "USD",
  "value": 29.99
}
```

#### Payment Item
```typescript
{
  "label": "Premium Subscription",
  "amount": {
    "currency": "USD",
    "value": 29.99
  },
  "pending": false,
  "refund_period": 30
}
```

### Payment Request
Complete payment request structure:

```typescript
{
  "method_data": [{
    "supported_methods": "basic-card",
    "data": {
      "supportedNetworks": ["visa", "mastercard"]
    }
  }],
  "details": {
    "id": "order-123",
    "total": {
      "label": "Total",
      "amount": {"currency": "USD", "value": 29.99}
    },
    "display_items": [
      {"label": "Subscription", "amount": {"currency": "USD", "value": 29.99}}
    ]
  },
  "options": {
    "request_payer_email": true,
    "request_shipping": false
  }
}
```

### Mandates: Authorization Framework

#### Intent Mandate
User's purchase intent and constraints:

```typescript
{
  "user_cart_confirmation_required": true,
  "natural_language_description": "Buy a laptop under $1500 from trusted retailers",
  "merchants": ["BestBuy", "Amazon"],
  "requires_refundability": true,
  "intent_expiry": "2025-12-31T23:59:59Z"
}
```

**What it means:** "I authorize the agent to buy a laptop, but I want to confirm the cart before purchase, it must be refundable, and only from these merchants."

#### Cart Mandate
Merchant's signed cart with guaranteed prices:

```typescript
{
  "contents": {
    "id": "cart-456",
    "merchant_name": "BestBuy",
    "user_cart_confirmation_required": true,
    "payment_request": {/* payment details */},
    "cart_expiry": "2025-10-10T12:00:00Z"
  },
  "merchant_authorization": "eyJhbGc..."
}
```

**What it means:** Merchant guarantees these items at these prices until expiry. The JWT proves authenticity.

#### Payment Mandate
Final payment authorization with user signature:

```typescript
{
  "payment_mandate_contents": {
    "payment_mandate_id": "pm-789",
    "payment_details_id": "order-123",
    "payment_details_total": {/* total amount */},
    "payment_response": {/* chosen payment method */},
    "merchant_agent": "bestbuy-agent-did",
    "timestamp": "2025-10-10T10:30:00Z"
  },
  "user_authorization": "eyJhbGc..."
}
```

**What it means:** User's cryptographic signature authorizing the payment. Shared with payment networks for trust.

---

## Agent Discovery & Capabilities

### Agent Card
The "business card" that describes an agent:

```typescript
{
  "id": "uuid",
  "name": "Data Analysis Agent",
  "description": "Analyzes datasets and generates insights",
  "url": "https://agent.example.com",
  "version": "1.0.0",
  "protocol_version": "0.3.0",
  "kind": "agent",
  
  "skills": [{
    "id": "data-analysis",
    "name": "Data Analysis",
    "description": "Analyze CSV and JSON datasets",
    "tags": ["analytics", "data", "statistics"],
    "input_modes": ["text/csv", "application/json"],
    "output_modes": ["text/plain", "application/json"],
    "examples": [
      "Analyze this sales data and find trends",
      "Calculate statistics for this dataset"
    ]
  }],
  
  "capabilities": {
    "streaming": true,
    "push_notifications": true,
    "extensions": [{
      "uri": "https://bindu.me/extensions/advanced-analytics",
      "required": false
    }]
  },
  
  "agent_trust": {
    "identity_provider": "keycloak",
    "inherited_roles": [],
    "creator_id": "creator-uuid",
    "trust_verification_required": true
  },
  
  "default_input_modes": ["text/plain"],
  "default_output_modes": ["text/plain"]
}
```

### Skills
Skills define what an agent can do. Two styles are supported:

#### Inline Skills (Simple)
All metadata in the config:

```typescript
{
  "id": "email-sender",
  "name": "Email Sender",
  "description": "Send emails to recipients",
  "tags": ["communication", "email"],
  "input_modes": ["text/plain"],
  "output_modes": ["text/plain"],
  "examples": ["Send an email to john@example.com"]
}
```

#### File-Based Skills (Rich Documentation)
Claude-style with detailed SKILL.md files:

```typescript
{
  "id": "pdf-processor",
  "name": "PDF Processor",
  "description": "Extract and process PDF documents",
  "tags": ["documents", "pdf", "extraction"],
  "input_modes": ["application/pdf"],
  "output_modes": ["text/plain", "application/json"],
  
  "documentation_path": "./skills/pdf-processor/SKILL.md",
  "documentation_content": "# PDF Processor\n\n## When to Use...",
  
  "capabilities_detail": {
    "text_extraction": {"supported": true, "types": ["standard", "ocr"]},
    "form_filling": {"supported": true}
  },
  
  "requirements": {
    "packages": ["pypdf", "pdfplumber"],
    "system": ["tesseract-ocr"],
    "min_memory_mb": 512
  },
  
  "performance": {
    "avg_processing_time_ms": 2000,
    "max_file_size_mb": 50
  },
  
  "allowed_tools": ["Read", "Write"]
}
```

---

## JSON-RPC Protocol

All communication uses JSON-RPC 2.0 format.

### Request Structure
```typescript
{
  "jsonrpc": "2.0",
  "id": "uuid",
  "method": "message/send",
  "params": {
    "message": {/* message object */},
    "configuration": {
      "accepted_output_modes": ["text/plain"],
      "blocking": false
    }
  }
}
```

### Response Structure
```typescript
{
  "jsonrpc": "2.0",
  "id": "uuid",
  "result": {/* success result */},
  "error": {
    "code": -32600,
    "message": "Invalid request",
    "data": {}
  }
}
```

### Available Methods

**Task Operations:**
- **message/send**: Send a message to create or update a task
- **message/stream**: Stream a message for real-time updates
- **tasks/get**: Retrieve task details
- **tasks/list**: List all tasks
- **tasks/cancel**: Cancel a running task
- **tasks/feedback**: Provide feedback on completed task
- **tasks/resubscribe**: Resubscribe to task updates

**Context Operations:**
- **contexts/list**: List all contexts
- **contexts/clear**: Clear a context

**Notification Operations:**
- **tasks/pushNotification/set**: Configure push notifications
- **tasks/pushNotification/get**: Get notification config
- **tasks/pushNotificationConfig/list**: List all configs
- **tasks/pushNotificationConfig/delete**: Remove a config

### Error Codes

#### Standard JSON-RPC Errors
- **-32700**: Parse error (invalid JSON)
- **-32600**: Invalid request (malformed structure)
- **-32601**: Method not found
- **-32602**: Invalid params
- **-32603**: Internal error

#### A2A Protocol Errors
- **-32001**: Task not found
- **-32002**: Task not cancelable
- **-32003**: Push notifications not supported
- **-32004**: Unsupported operation
- **-32005**: Content type not supported
- **-32006**: Invalid agent response
- **-32007**: Authenticated card not configured
- **-32008**: Task immutable (terminal state)

#### Bindu Authentication Errors
- **-32009**: Authentication required
- **-32010**: Invalid token
- **-32011**: Token expired
- **-32012**: Invalid token signature
- **-32013**: Insufficient permissions

#### Bindu Context Errors
- **-32020**: Context not found
- **-32021**: Context not cancelable

#### Bindu Skill Errors
- **-32030**: Skill not found

---

## Agent Negotiation

For multi-agent coordination and resource negotiation:

### Negotiation Proposal
```typescript
{
  "proposal_id": "uuid",
  "from_agent": "agent-1-uuid",
  "to_agent": "agent-2-uuid",
  "terms": {
    "task_type": "data-processing",
    "max_duration_minutes": 30,
    "cost_credits": 100
  },
  "timestamp": "2025-10-10T10:00:00Z",
  "status": "proposed"
}
```

### Negotiation Context
```typescript
{
  "context_id": "uuid",
  "status": "ongoing",
  "participants": ["agent-1-did", "agent-2-did"],
  "proposals": [/* array of proposals */]
}
```

**Negotiation Statuses:**
- **proposed**: Initial offer made
- **accepted**: Offer accepted
- **rejected**: Offer declined
- **countered**: Counter-offer made

**Session Statuses:**
- **initiated**: Negotiation started
- **ongoing**: Active negotiation
- **completed**: Agreement reached
- **rejected**: Negotiation failed

---

## Agent Execution & Credits

### Execution Cost
Define how much it costs to run an agent:

```typescript
{
  "agent_id": "agent-123",
  "agent_name": "Premium Analyzer",
  "credits_per_request": 100,
  "creator_did": "did:example:creator",
  "minimum_trust_level": "analyst"
}
```

### Execution Request
```typescript
{
  "request_id": "uuid",
  "executor_did": "did:example:user",
  "agent_id": "agent-123",
  "input_data": "Analyze this dataset...",
  "estimated_credits": 100,
  "trust_level": "analyst"
}
```

### Execution Response
```typescript
{
  "request_id": "uuid",
  "execution_id": "uuid",
  "success": true,
  "credits_charged": 95,
  "transaction_id": "uuid",
  "output_data": "Analysis complete...",
  "execution_time": "2025-10-10T10:05:00Z"
}
```

---

## Summary

The Bindu protocol types provide a complete vocabulary for agent communication:

- **Parts** (Text, File, Data) - Content building blocks
- **Messages** - Operational communication
- **Artifacts** - Final deliverable results
- **Tasks** - Work coordination units
- **Contexts** - Conversation sessions
- **Security** - Authentication and authorization
- **Payments** - Commerce and transactions
- **Agent Cards** - Capability discovery
- **JSON-RPC** - Communication protocol

Each type serves a specific purpose in enabling agents to work together effectively, securely, and transparently.
