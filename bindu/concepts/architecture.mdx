---
title: "Architecture: How Bindu Works"
---


In [Key Concepts](/bindu/introduction/key-concepts), you saw how Bindu's task lifecycle enables interactive conversations with states like `submitted`, `input-required`, and `completed`. This guide explains the **technical architecture** that makes it possible—from protocol layers to storage backends.

**What You'll Learn:**
- How requests flow through Bindu's layered architecture
- Why TaskManager coordinates everything (the "restaurant manager")
- How workers execute your agent asynchronously
- Storage, caching, and scaling strategies

**Quick Context:** When you send a message, it creates a task that flows through multiple layers. This page shows you what happens at each layer and why.

## System Overview

```mermaid
graph TB
    subgraph "Client Layer"
        Client[Client/Orchestrator]
        Discovery[Agent Discovery]
    end
    
    subgraph "Protocol Layer"
        HTTP[HTTP/JSON-RPC]
        A2A[A2A Protocol v0.3.0]
        AP2[AP2 Protocol v0.1.0]
        X402[X402 Payment]
    end
    
    subgraph "Security Layer"
        Auth[Authentication]
        DID[DID Identity]
        PKI[PKI/Crypto]
    end
    
    subgraph "Application Layer"
        Server[BinduApplication<br/>Starlette Web Server]
        Router[Request Router]
        Validator[Schema Validator]
    end
    
    subgraph "Orchestration Layer"
        Manager[TaskManager<br/>Central Coordinator]
        Queue[Task Queue]
        Worker[Worker Pool]
    end
    
    subgraph "Storage Layer"
        Storage[(Storage Backend<br/>Memory/PostgreSQL)]
        Cache[(Cache Layer<br/>Redis)]
    end
    
    subgraph "Agent Layer"
        Agent[Your AI Agent<br/>LangChain/CrewAI/Agno]
        Skills[Skills Registry]
        Tools[Tool Integrations]
    end
    
    subgraph "Observability Layer"
        Traces[Distributed Tracing<br/>Jaeger/OTLP]
        LLMObs[LLM Observability<br/>Phoenix/Langfuse]
        Metrics[Metrics & Logs]
    end
    
    Client --> Discovery
    Discovery --> HTTP
    HTTP --> A2A
    HTTP --> AP2
    HTTP --> X402
    
    A2A --> Auth
    AP2 --> Auth
    X402 --> Auth
    
    Auth --> DID
    Auth --> PKI
    
    DID --> Server
    PKI --> Server
    
    Server --> Router
    Router --> Validator
    Validator --> Manager
    
    Manager --> Queue
    Manager <--> Storage
    Queue --> Worker
    Worker <--> Storage
    Worker <--> Cache
    
    Worker --> Agent
    Agent --> Skills
    Agent --> Tools
    
    Server -.traces.-> Traces
    Manager -.traces.-> Traces
    Worker -.traces.-> Traces
    Agent -.traces.-> LLMObs
    
    Manager -.metrics.-> Metrics
    Worker -.metrics.-> Metrics
    
    style Client fill:#e1f5ff
    style Discovery fill:#d4f5e1
    style HTTP fill:#fff4e1
    style A2A fill:#e1ffe1
    style AP2 fill:#e1ffe1
    style X402 fill:#98fb98
    style Auth fill:#ffd4e1
    style DID fill:#ffd4e1
    style PKI fill:#ffd4e1
    style Server fill:#ffe1f5
    style Router fill:#ffe1f5
    style Validator fill:#ffe1f5
    style Manager fill:#e1e1ff
    style Queue fill:#e1e1ff
    style Worker fill:#e1e1ff
    style Storage fill:#ffe1e1
    style Cache fill:#ffe1e1
    style Agent fill:#e1f5ff
    style Skills fill:#e1f5ff
    style Tools fill:#e1f5ff
    style Traces fill:#ffd700
    style LLMObs fill:#ffd700
    style Metrics fill:#ffd700
```

---

## Core Components

### 1. Protocol Layer

**A2A Protocol** - Agent-to-agent communication (task lifecycle, context management)  
**AP2 Protocol** - Commerce extensions (payment mandates, cart management)  
**X402 Protocol** - Micropayments (cryptographic signatures, multi-currency)

All use JSON-RPC 2.0 for request/response handling.

---
### 2. Security & Identity Layer

**Authentication** - Auth0, OAuth2, API Keys, Mutual TLS  
**DID (Decentralized Identity)** - Unique, verifiable agent identity  
**PKI** - RSA/ECDSA key generation, signature verification

---
### 3. Application Layer

**BinduApplication** - Starlette-based web server with async/await, WebSocket support  
**Request Router** - Routes to `/agent/card`, `/agent/skills`, `/tasks/*`, `/contexts/*`  
**Schema Validator** - Validates request structure and types

---
### 4. Orchestration Layer

**TaskManager** - Central coordinator that creates tasks, manages state, coordinates workers  
**Task Queue** - Memory (dev) or Redis (prod) for distributed task scheduling  
**Worker Pool** - Executes tasks asynchronously, handles retries and timeouts

---
### 5. Storage Layer

**Memory Storage** (dev) - In-memory dictionaries for tasks, contexts, artifacts  
**PostgreSQL** (prod) - ACID compliance, relational queries, JSON support  
**Redis Cache** - Session storage, rate limiting, pub/sub notifications

---
### 6. Agent Layer

**Framework Agnostic** - Works with Agno, LangChain, CrewAI, LlamaIndex  
**Skills Registry** - Defines agent capabilities via `/agent/skills` endpoint  
**Tool Integrations** - 113+ built-in toolkits for data, code, web, APIs

---
### 7. Observability Layer

**Distributed Tracing** - Jaeger/OTLP tracks requests across all components  
**LLM Observability** - Phoenix/Langfuse monitors token usage, latency, cost  
**Metrics** - Request rate, task duration, error rate, queue depth, worker utilization

---

## Data Flow

### Complete Request Lifecycle

Let's trace a complete request through the system:


```mermaid
%%{init: {'theme':'base', 'themeVariables': { 'fontSize':'11px'}}}%%
sequenceDiagram
    participant Client
    participant Server as BinduApplication
    participant Auth as Auth Layer
    participant Manager as TaskManager
    participant Storage as Storage
    participant Queue as Scheduler
    participant Worker as Worker
    participant Agent as AI Agent
    participant Obs as Observability
    
    Client->>Server: POST / (message/send)
    Server->>Obs: Start trace
    Server->>Auth: Verify credentials
    Auth-->>Server: Authenticated
    
    Server->>Manager: Create task
    Manager->>Storage: Save task (status: submitted)
    Storage-->>Manager: Task saved
    Manager->>Queue: Enqueue task_id
    Queue-->>Manager: Queued
    Manager-->>Server: Task created
    Server-->>Client: 200 OK (task with submitted state)
    
    Note over Client,Server: Client can poll or use webhooks
    
    Queue->>Worker: Dequeue task_id
    Worker->>Storage: Get task details
    Storage-->>Worker: Task data
    Worker->>Manager: Update status (working)
    Manager->>Storage: Update status
    Manager->>Client: Push notification (working)
    
    Worker->>Agent: Execute with messages
    Agent->>Obs: Log LLM calls
    Agent-->>Worker: Result
    
    Worker->>Manager: Complete task
    Manager->>Storage: Save artifact
    Manager->>Storage: Update status (completed)
    Manager->>Client: Push notification (completed)
    Manager->>Obs: End trace
    
    Client->>Server: POST / (tasks/get)
    Server->>Storage: Get task
    Storage-->>Server: Task + artifact
    Server-->>Client: 200 OK (task with artifacts)
```

### Request Flow Summary

**Phase 1: Submit (0-50ms)** - Client sends `message/send` → Auth validates → TaskManager creates task → Returns `task_id` immediately

**Phase 2: Execute (async)** - Worker dequeues → Runs your agent → Updates state (`working` → `input-required` or `completed`)

**Phase 3: Retrieve (anytime)** - Client polls with `tasks/get` → Gets current state + artifacts

---

## Summary

Bindu's architecture is designed for:

- **Simplicity**: Wrap any agent with minimal code
- **Scalability**: From localhost to distributed cloud
- **Reliability**: Built-in error handling and recovery
- **Observability**: Complete visibility into operations
- **Security**: Authentication and identity built-in
- **Standards**: Protocol-first design (A2A, AP2, X402)

The layered architecture ensures each component can evolve independently while maintaining a cohesive system. Whether you're prototyping locally or deploying at scale, Bindu's architecture adapts to your needs.

### Connecting the Dots

**You've now seen three perspectives:**

1. **[Key Concepts](/bindu/introduction/key-concepts)** - How task states enable interactive conversations
2. **This Page (Architecture)** - The technical layers that power those states
3. **[Task-First Pattern](/bindu/concepts/task-first-pattern)** - Why this design enables multi-agent orchestration

**The Big Picture:** When you send "create sunset caption" and the agent asks "which platform?", here's what happens:
- Your message hits the Protocol Layer → authenticated by Security Layer
- TaskManager creates a task in "submitted" state → stored in Storage Layer
- Worker executes your agent → agent returns structured response requesting input
- TaskManager updates state to "input-required" → you see the question
- You respond "Instagram" → same task continues → completes with artifact

That's Bindu's architecture in action.

---

## Next Steps

<CardGroup cols={2}>
  <Card title="Protocol Types" icon="code" href="/bindu/concepts/protocol">
    Learn about the data structures and types
  </Card>
  <Card title="Create Your Agent" icon="rocket" href="/bindu/create-bindu-agent/overview">
    Build your first Bindu agent
  </Card>
  <Card title="Observability" icon="eye" href="/bindu/learn/observability/introduction">
    Set up monitoring and tracing
  </Card>
  <Card title="Authentication" icon="shield" href="/bindu/learn/authentication/auth0">
    Configure security and auth
  </Card>
</CardGroup>