---
title: 'Protocol Types'
description: 'Complete reference for Pebbling Protocol type definitions used for communication between agents and the framework'
---

# Pebbling Protocol Types

The Pebbling Protocol defines a comprehensive set of type definitions for communication between agents and the Pebbling framework. These types ensure type-safe, structured communication across all system components.

## Core Communication Types

### Message Parts

The protocol supports multi-part messages with different content types:

#### TextPart
```python
class TextPart(TypedDict):
    kind: Required[Literal["text"]]
    metadata: NotRequired[dict[str, Any]]
    text: Required[str]
    embeddings: NotRequired[list[float]]
```

#### FilePart
```python
class FilePart(TextPart):
    kind: Required[Literal["file"]]
    file: Required[FileWithBytes | FileWithUri]
```

#### DataPart
```python
class DataPart(TextPart):
    kind: Required[Literal["data"]]
    data: Required[dict[str, Any]]
    embeddings: NotRequired[list[float]]
```

### Core Protocol Entities

## Artifacts

Artifacts represent the final output generated by an agent after completing a task. They are immutable data structures containing the results of agent execution.

```python
class Artifact(TypedDict):
    artifact_id: Required[UUID]
    name: NotRequired[str]
    description: NotRequired[str]
    metadata: NotRequired[dict[str, Any]]
    parts: NotRequired[list[Part]]
    append: NotRequired[bool]
    last_chunk: NotRequired[bool]
    extra_data: NotRequired[dict[str, Any]]
```

**Key Properties:**
- **Immutable**: Once created, artifacts cannot be modified
- **Multi-part**: Can contain text, files, and structured data
- **Streamable**: Parts can be appended during streaming responses
- **Traceable**: Each artifact has a unique ID for reference

## Messages

Messages represent all non-result communication in the Pebbling protocol, carrying operational content like instructions, status updates, and metadata.

```python
class Message(TypedDict):
    context_id: Required[UUID]
    task_id: Required[UUID]
    reference_task_ids: NotRequired[list[UUID]]
    message_id: Required[UUID]
    kind: Required[Literal["message"]]
    metadata: NotRequired[dict[str, Any]]
    parts: Required[list[Part]]
    role: Required[Role]
    extra_data: NotRequired[dict[str, Any]]
```

**Message Types:**
- **User Instructions**: Task requests with context and files
- **Agent Communication**: Status updates, thoughts, coordination
- **System Messages**: Errors, warnings, protocol information
- **Context Sharing**: Background information, references, metadata

## Tasks

Tasks serve as the primary coordination mechanism, managing the complete lifecycle from request to completion.

```python
class Task(TypedDict):
    task_id: Required[UUID]
    context_id: Required[UUID]
    kind: Required[Literal["task"]]
    status: Required[TaskStatus]
    artifacts: NotRequired[list[Artifact]]
    history: NotRequired[list[Message]]
    metadata: NotRequired[dict[str, Any]]
```

**Core Responsibilities:**
- **Message Exchange**: Facilitate communication between clients and agents
- **State Management**: Track task progress and execution status
- **Artifact Collection**: Gather and organize agent-generated outputs
- **History Tracking**: Maintain complete conversation and decision trail

**Task Lifecycle:**
1. **Creation**: Client initiates task with initial message/requirements
2. **Processing**: Agent processes messages and updates status
3. **Communication**: Bidirectional message exchange as needed
4. **Artifact Generation**: Agent produces deliverable outputs
5. **Completion**: Final status update and artifact delivery

## Contexts

Contexts serve as conversation containers, managing the complete interaction lifecycle between clients and agents.

```python
class Context(TypedDict):
    context_id: Required[UUID]
    kind: Required[Literal["context"]]
    tasks: NotRequired[list[UUID]]
    name: NotRequired[str]
    description: NotRequired[str]
    role: Required[str]
    created_at: Required[str]
    updated_at: Required[str]
    status: NotRequired[Literal["active", "paused", "completed", "archived"]]
    tags: NotRequired[list[str]]
    metadata: NotRequired[dict[str, Any]]
    parent_context_id: NotRequired[UUID]
    reference_context_ids: NotRequired[list[UUID]]
    extra_data: NotRequired[dict[str, Any]]
```

**Core Responsibilities:**
- **Session Management**: Group related tasks under a unified conversation
- **History Preservation**: Maintain complete message history across tasks
- **Context Continuity**: Preserve conversation state and references
- **Metadata Tracking**: Store session-level information and preferences

## Type Aliases

### Task States
```python
TaskState: TypeAlias = Literal[
    "submitted", "working", "input-required", "completed", 
    "canceled", "failed", "rejected", "auth-required", 
    "unknown", "trust-verification-required", "pending", 
    "suspended", "resumed", "negotiation-bid-submitted", 
    "negotiation-bid-lost", "negotiation-bid-won"
]
```

### Roles
```python
Role: TypeAlias = Literal["agent", "user"]
```

### Run Modes
```python
RunMode: TypeAlias = Literal[
    "sync",    # Synchronous execution, wait for complete response
    "async",   # Asynchronous execution, don't wait for response
    "stream"   # Streaming execution, receive partial results
]
```

### Trust Levels
```python
TrustLevel: TypeAlias = Literal[
    "admin", "analyst", "auditor", "editor", "guest",
    "manager", "operator", "super_admin", "support", "viewer"
]
```

## Security & Authentication

The protocol supports multiple security schemes for API authentication:

### HTTP Security Scheme
```python
class HttpSecurityScheme(TypedDict):
    type: Required[Literal["http"]]
    scheme: Required[str]
    bearer_format: NotRequired[str]
    description: NotRequired[str]
```

### API Key Security Scheme
```python
class ApiKeySecurityScheme(TypedDict):
    type: Required[Literal["apiKey"]]
    name: Required[str]
    in_: Required[Literal["query", "header", "cookie"]]
    description: NotRequired[str]
```

### OAuth2 Security Scheme
```python
class OAuth2SecurityScheme(TypedDict):
    type: Required[Literal["oauth2"]]
    flows: Required[dict[str, Any]]
    description: NotRequired[str]
```

## Agent Execution & Credits

The protocol includes types for managing agent execution costs and credit-based billing:

### Agent Execution Cost
```python
class AgentExecutionCost(TypedDict):
    agent_id: Required[str]
    agent_name: Required[str]
    credits_per_request: Required[int]
    creator_did: Required[str]
    minimum_trust_level: Required[TrustLevel]
```

### Execution Request/Response
```python
class ExecutionRequest(TypedDict):
    request_id: Required[UUID]
    executor_did: Required[str]
    agent_id: Required[str]
    input_data: Required[str]
    estimated_credits: Required[int]
    trust_level: Required[TrustLevel]

class ExecutionResponse(TypedDict):
    request_id: Required[UUID]
    execution_id: Required[UUID]
    success: Required[bool]
    credits_charged: Required[int]
    transaction_id: NotRequired[UUID]
    output_data: NotRequired[str]
    error_message: NotRequired[str]
    execution_time: Required[str]
```

## Negotiation System

The protocol supports agent-to-agent negotiations:

### Negotiation Proposal
```python
class NegotiationProposal(TypedDict):
    proposal_id: Required[UUID]
    from_agent: Required[UUID]
    to_agent: Required[UUID]
    terms: Required[Dict[str, Any]]
    timestamp: Required[str]
    status: Required[NegotiationStatus]
```

### Negotiation Session
```python
class NegotiationSession(TypedDict):
    session_id: Required[UUID]
    status: Required[NegotiationSessionStatus]
    participants: Required[List[UUID]]
    proposals: Required[List[NegotiationProposal]]
```

## Push Notifications

Support for real-time notifications outside of connected sessions:

```python
class PushNotificationConfig(TypedDict):
    id: Required[UUID]
    url: Required[str]
    token: NotRequired[str]
    authentication: NotRequired[SecurityScheme]
```

## Event Types

The protocol defines events for real-time updates:

### Task Status Update Event
```python
class TaskStatusUpdateEvent(TypedDict):
    context_id: Required[UUID]
    final: Required[bool]
    kind: Required[Literal["status-update"]]
    metadata: NotRequired[dict[str, Any]]
    status: Required[TaskStatus]
    task_id: Required[UUID]
```

### Task Artifact Update Event
```python
class TaskArtifactUpdateEvent(TypedDict):
    append: NotRequired[bool]
    artifact: Required[Artifact]
    context_id: Required[UUID]
    kind: Required[Literal["artifact-update"]]
    last_chunk: NotRequired[bool]
    metadata: NotRequired[dict[str, Any]]
    task_id: Required[UUID]
```

## Implementation Notes

- All types use **Pydantic** for validation and serialization
- **CamelCase** conversion is handled automatically via `alias_generator`
- **UUID** types ensure unique identification across the system
- **TypedDict** provides static type checking while maintaining runtime flexibility
- **Discriminated unions** enable type-safe polymorphism for different message/artifact types

The protocol is designed to be **extensible**, **type-safe**, and **backwards-compatible**, ensuring robust communication between all system components.
